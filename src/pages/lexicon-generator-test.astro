---
import Layout from '../layouts/Layout.astro';
import { loadConfig } from '../lib/config/site';

const config = loadConfig();
---

<Layout title="Lexicon Generator Test">
  <div class="container mx-auto px-4 py-8">
    <h1 class="text-4xl font-bold mb-8">Lexicon Generator Test</h1>
    
    <div class="bg-blue-50 border border-blue-200 rounded-lg p-6 mb-8">
      <h2 class="text-2xl font-semibold mb-4">Configuration</h2>
      <p><strong>Handle:</strong> {config.atproto.handle}</p>
      <p><strong>DID:</strong> {config.atproto.did}</p>
      <p class="text-sm text-gray-600 mt-2">Generate TypeScript types for all lexicons discovered in your configured repository.</p>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
      <div class="bg-white border border-gray-200 rounded-lg p-6">
        <h2 class="text-2xl font-semibold mb-4">Generate Types</h2>
        <div class="space-y-4">
          <p class="text-sm text-gray-600">Generating types for: <strong>{config.atproto.handle}</strong></p>
          <button id="generate-btn" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700">
            Generate Types for My Repository
          </button>
        </div>
      </div>

      <div class="bg-white border border-gray-200 rounded-lg p-6">
        <h2 class="text-2xl font-semibold mb-4">Generation Status</h2>
        <div id="status" class="space-y-2">
          <p class="text-gray-500">Click generate to analyze your repository...</p>
        </div>
      </div>
    </div>

    <div class="mt-8">
      <h2 class="text-2xl font-semibold mb-4">Discovered Lexicons</h2>
      <div id="lexicons-container" class="space-y-4">
        <p class="text-gray-500 text-center py-8">No lexicons discovered yet...</p>
      </div>
    </div>

    <div class="mt-8">
      <h2 class="text-2xl font-semibold mb-4">Generated TypeScript Types</h2>
      <div class="bg-gray-900 text-green-400 p-4 rounded-lg">
        <pre id="types-output" class="text-sm overflow-x-auto">// Generated types will appear here...</pre>
      </div>
      <div class="mt-4">
        <button id="copy-btn" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700" disabled>
          Copy to Clipboard
        </button>
        <button id="download-btn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 ml-2" disabled>
          Download Types File
        </button>
      </div>
    </div>
  </div>
</Layout>

<script>
  // Simple lexicon generator for your configured account
  class SimpleLexiconGenerator {
    constructor() {
      this.config = {
        handle: 'tynanpurdy.com',
        did: 'did:plc:6ayddqghxhciedbaofoxkcbs',
        pdsUrl: 'https://bsky.social'
      };
    }

    async generateTypesForRepository() {
      console.log('ðŸ” Generating types for repository:', this.config.handle);
      
      const lexicons = [];
      const collectionTypes = {};

      try {
        // Get all collections in the repository
        const collections = await this.getAllCollections();
        console.log(`ðŸ“Š Found ${collections.length} collections:`, collections);

        // Analyze each collection
        for (const collection of collections) {
          console.log(`ðŸ” Analyzing collection: ${collection}`);
          
          try {
            const collectionInfo = await this.getCollectionRecords(collection, 100);
            if (collectionInfo && collectionInfo.records.length > 0) {
              // Group records by type
              const typeGroups = new Map();
              
              collectionInfo.records.forEach(record => {
                const $type = record.$type;
                if (!typeGroups.has($type)) {
                  typeGroups.set($type, []);
                }
                typeGroups.get($type).push(record);
              });

              // Create lexicon definitions for each type
              typeGroups.forEach((records, $type) => {
                const sampleRecord = records[0];
                const properties = this.extractProperties(sampleRecord.value);
                
                const lexicon = {
                  $type,
                  collection,
                  properties,
                  sampleRecord,
                  description: `Discovered in collection ${collection}`
                };
                
                lexicons.push(lexicon);
                
                // Track collection types
                if (!collectionTypes[collection]) {
                  collectionTypes[collection] = [];
                }
                collectionTypes[collection].push($type);
                
                console.log(`âœ… Generated lexicon for ${$type} in ${collection}`);
              });
            }
          } catch (error) {
            console.error(`âŒ Error analyzing collection ${collection}:`, error);
          }
        }

        // Generate TypeScript type definitions
        const typeDefinitions = this.generateTypeScriptTypes(lexicons, collectionTypes);
        
        console.log(`ðŸŽ‰ Generated ${lexicons.length} lexicon definitions`);
        
        return {
          lexicons,
          typeDefinitions,
          collectionTypes
        };

      } catch (error) {
        console.error('Error generating types:', error);
        throw error;
      }
    }

    async getAllCollections() {
      try {
        const response = await fetch(`https://bsky.social/xrpc/com.atproto.repo.describeRepo?repo=${this.config.did}`);
        const data = await response.json();
        return data.collections || [];
      } catch (error) {
        console.error('Error getting collections:', error);
        return [];
      }
    }

    async getCollectionRecords(collection, limit = 100) {
      try {
        const response = await fetch(`https://bsky.social/xrpc/com.atproto.repo.listRecords?repo=${this.config.did}&collection=${collection}&limit=${limit}`);
        const data = await response.json();
        
        const records = data.records.map(record => ({
          uri: record.uri,
          cid: record.cid,
          value: record.value,
          indexedAt: record.indexedAt,
          collection: collection,
          $type: record.value?.$type || 'unknown',
        }));

        return {
          collection: collection,
          recordCount: records.length,
          records: records,
          cursor: data.cursor,
        };
      } catch (error) {
        console.error('Error getting collection records:', error);
        return null;
      }
    }

    extractProperties(value) {
      const properties = {};
      
      if (value && typeof value === 'object') {
        Object.keys(value).forEach(key => {
          if (key !== '$type') {
            properties[key] = {
              type: typeof value[key],
              value: value[key]
            };
          }
        });
      }
      
      return properties;
    }

    generateTypeScriptTypes(lexicons, collectionTypes) {
      let types = '// Auto-generated TypeScript types for discovered lexicons\n';
      types += '// Generated from ATProto repository analysis\n\n';

      // Generate interfaces for each lexicon
      lexicons.forEach(lexicon => {
        const interfaceName = this.generateInterfaceName(lexicon.$type);
        types += `export interface ${interfaceName} {\n`;
        types += `  $type: '${lexicon.$type}';\n`;
        
        Object.entries(lexicon.properties).forEach(([key, prop]) => {
          const type = this.getTypeScriptType(prop.type, prop.value);
          types += `  ${key}: ${type};\n`;
        });
        
        types += '}\n\n';
      });

      // Generate collection type mappings
      types += '// Collection type mappings\n';
      types += 'export interface CollectionTypes {\n';
      Object.entries(collectionTypes).forEach(([collection, types]) => {
        types += `  '${collection}': ${types.map(t => `'${t}'`).join(' | ')};\n`;
      });
      types += '}\n\n';

      // Generate union types for all lexicons
      const allTypes = lexicons.map(l => this.generateInterfaceName(l.$type));
      types += `export type AllLexicons = ${allTypes.join(' | ')};\n\n`;

      // Generate helper functions
      types += '// Helper functions\n';
      types += 'export function isLexiconType(record: any, type: string): boolean {\n';
      types += '  return record?.$type === type;\n';
      types += '}\n\n';

      types += 'export function getCollectionTypes(collection: string): string[] {\n';
      types += '  const collectionTypes: Record<string, string[]> = {\n';
      Object.entries(collectionTypes).forEach(([collection, types]) => {
        types += `    '${collection}': [${types.map(t => `'${t}'`).join(', ')}],\n`;
      });
      types += '  };\n';
      types += '  return collectionTypes[collection] || [];\n';
      types += '}\n';

      return types;
    }

    generateInterfaceName($type) {
      return $type
        .split('.')
        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
        .join('');
    }

    getTypeScriptType(jsType, value) {
      switch (jsType) {
        case 'string':
          return 'string';
        case 'number':
          return typeof value === 'number' && Number.isInteger(value) ? 'number' : 'number';
        case 'boolean':
          return 'boolean';
        case 'object':
          if (Array.isArray(value)) {
            return 'any[]';
          }
          return 'Record<string, any>';
        default:
          return 'any';
      }
    }
  }

  const generator = new SimpleLexiconGenerator();
  let generatedTypes = '';

  // DOM elements
  const generateBtn = document.getElementById('generate-btn') as HTMLButtonElement;
  const status = document.getElementById('status') as HTMLDivElement;
  const lexiconsContainer = document.getElementById('lexicons-container') as HTMLDivElement;
  const typesOutput = document.getElementById('types-output') as HTMLPreElement;
  const copyBtn = document.getElementById('copy-btn') as HTMLButtonElement;
  const downloadBtn = document.getElementById('download-btn') as HTMLButtonElement;

  function updateStatus(message: string, isError = false) {
    status.innerHTML = `
      <p class="${isError ? 'text-red-600' : 'text-green-600'}">${message}</p>
    `;
  }

  function displayLexicons(lexicons: any[]) {
    if (lexicons.length === 0) {
      lexiconsContainer.innerHTML = '<p class="text-gray-500 text-center py-8">No lexicons discovered</p>';
      return;
    }

    lexiconsContainer.innerHTML = `
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        ${lexicons.map(lexicon => `
          <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
            <h3 class="font-semibold text-gray-900 mb-2">${lexicon.$type}</h3>
            <p class="text-sm text-gray-600 mb-2">Collection: ${lexicon.collection}</p>
            <p class="text-sm text-gray-600 mb-2">Properties: ${Object.keys(lexicon.properties).length}</p>
            <p class="text-xs text-gray-500">${lexicon.description}</p>
          </div>
        `).join('')}
      </div>
    `;
  }

  function displayTypes(types: string) {
    generatedTypes = types;
    typesOutput.textContent = types;
    copyBtn.disabled = false;
    downloadBtn.disabled = false;
  }

  generateBtn.addEventListener('click', async () => {
    try {
      generateBtn.disabled = true;
      generateBtn.textContent = 'Generating...';
      updateStatus('Starting type generation...');

      // Generate types
      const result = await generator.generateTypesForRepository();
      
      updateStatus(`Generated ${result.lexicons.length} lexicon types successfully!`);
      displayLexicons(result.lexicons);
      displayTypes(result.typeDefinitions);

    } catch (error) {
      console.error('Error generating types:', error);
      updateStatus('Error generating types. Check the console for details.', true);
    } finally {
      generateBtn.disabled = false;
      generateBtn.textContent = 'Generate Types for My Repository';
    }
  });

  copyBtn.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(generatedTypes);
      copyBtn.textContent = 'Copied!';
      setTimeout(() => {
        copyBtn.textContent = 'Copy to Clipboard';
      }, 2000);
    } catch (error) {
      console.error('Error copying to clipboard:', error);
      alert('Error copying to clipboard');
    }
  });

  downloadBtn.addEventListener('click', () => {
    try {
      const blob = new Blob([generatedTypes], { type: 'text/typescript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'generated-lexicons.ts';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Error downloading file:', error);
      alert('Error downloading file');
    }
  });
</script> 